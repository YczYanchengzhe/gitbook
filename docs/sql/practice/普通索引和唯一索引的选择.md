# 普通索引和唯一索引，应该怎么选择

## 查询过程
- 对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。
- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

上述不同所带来的的性能差距,微乎其微, 因为 InndDb 是按照页为单位读写的,所以读取一条记录时候并不是读记录本身,而是会把记录页也读取出来.

## 更新过程
### change buffer : 

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

### 什么条件下使用 change buffer ? 
- 唯一索引 : 由于所有的更新操作都要先判断这个操作是否违反唯一性约束,所以无法使用 change buffer.
- 对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。
- 假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价

### redo log 和 change buffer
redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。

### 更新过程
#### case 1 : 这个记录要更新的目标页在内存中 - 此时差距微乎其微
- 对于唯一索引来说，找到要更新数据之间的位置，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，找到要更新数据之间的位置，插入这个值，语句执行结束。

#### case2 : 记录要更新的目标页不在内存中
- 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。


## 索引选择

由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发我建议你优先考虑非唯一索引。






