# 如何正确的显示随机消息


## 内存临时表

```sql
select word from words order by rand() limit 3;
```

- 创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。
- 从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。
- 现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。
- 初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。
- 从内存临时表中一行一行地取出 R 值和位置信息，分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。
- 在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。
- 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。


## MySQL 的表是用什么方法来定位“一行数据”的
如果你创建的表没有主键，或者把一个表的主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 来作为主键。(这也就是排序模式里面，rowid 名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。)

- 对于有主键的 InnoDB 表来说，这个 rowid 就是主键 ID；
- 对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的；
- MEMORY 引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个 rowid 其实就是数组的下标。

## 磁盘临时表

```sql
tmp_table_size 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 tmp_table_size，那么内存临时表就会转成磁盘临时表。
```

### 优先队列排序算法 - MySQL 5.6 版本引入
现在的 SQL 语句，只需要取 R 值最小的 3 个 rowid ,如果使用归并,虽然最终也能得到三个值,但是算法结束后所有数据都排序了,我们实际上只需要三个最小值,于是可以借助**堆排序**来实现.


## 随机排序方法
#### 方法 1
- 取得这个表的主键 id 的最大值 M 和最小值 N;
- 用随机函数生成一个最大值到最小值之间的数 X = (M-N)*rand() + N;
- 取不小于 X 的第一个 ID 的行。

问题 :  数据空洞问题,导致选择不同行概率不一致

#### 方法 2
- 取得整个表的行数，并记为 C。
- 取得 Y = floor(C * rand())。 floor 函数在这里的作用，就是取整数部分。
- 再用 limit Y,1 取得一行。

问题 : 
由于MySQL 处理 limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前 Y 个，然后把下一个记录作为返回结果，因此这一步需要扫描 Y+1 行.再加上，第一步扫描的 C 行，总共需要扫描 C+Y+1 行，执行代价比随机算法 1 的代价要高。

#### 方法3
- 取得整个表的行数，并记为 C。
- 取得 Y = floor(C * rand())。 floor 函数在这里的作用，就是取整数部分。得到 Y1,Y2,Y3
- 取 Y1、Y2 和 Y3 里面最大的一个数，记为 M，最小的一个数记为 N (扫描行数 :C+M+1 )
	```sql
	select * from t limit N, M-N+1;
	```
- 从结果集中取出 Y2