# 索引

## 一.索引简介

#### 1.什么时候使用索引
- 数据量少的情况下使用索引效率并不高
- 数据重复度大的时候,比如高于10%的时候,对该字段新建索引所带来的优化并不多

#### 2.索引的种类
**按照功能逻辑分类 :** 

##### (1)普通索引
没有任何约束 , 主要用于提高查询效率.
##### (2)唯一索引
在普通索引基础上增加了数据额唯一性的约束 , 一张表中可以有多个唯一索引. UNIQUE
##### (3)主键索引
在唯一索引基础上增加不为空的约束. NOT NULL + UNIQUE
##### (4)全文索引
mysql自带的只支持英文


>其实前三种索引（普通索引、唯一索引和主键索引）都是一类索引，只不过对数据的约束性逐渐提升。在一张数据表中只能有一个主键索引，这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储

**按照物理实现方式分类**
##### (1)聚集索引
聚集索引可以按照主键来排序存储数据,在查找行的时候很高效.每一张表只能有一个聚集索引.效率略优于非聚集索引
##### (2)非聚集索引 : 也称二级索引/辅助索引
非聚集索引有单独的存储空间 ,索引项是按照顺序存储的,但是索引指向的内容是随机存储的.所以真正查询时候会查询两次,第一次找到索引,第二次找到索引对应位置取出数据行.
非聚集索引不直接指向数据,而是维护单独的索引表 ,指向索引.

##### (3)聚集索引和非聚集索引区别
- 聚集索引的叶子节点存储的就是我们的数据记录，非聚集索引的叶子节点存储的是数据位置。
- 非聚集索引不会影响数据表的物理存储顺序。(因为叶子结点无数据)
- 一个表只能有一个聚集索引，因为只能有一种排序存储的方式，但可以有多个非聚集索引，也就是多个索引目录提供数据检索。
- 使用聚集索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。

#### 3.索引的最左匹配原则
按照最左优先的方式进行索引的匹配。比如 (x, y, z)，如果查询条件是 WHERE x=1 AND y=2 AND z=3，就可以匹配上联合索引；如果查询条件是 WHERE y=2，就无法匹配上联合索引。

#### 4.索引的优缺点
> 优点 : 加快查询效率 IO : $$O(n) -> O(log n)$$
> 缺点 : 占用存储空间 , 降低数据库写入性能 , 多个索引还会增加索引选择时间 , 因为B+树是多路平衡查找树 , 数据的插入删除可能导致B+树重新平衡 ,对于聚集索引,可能导致数据迁移.

## 二.索引原理

#### 1.常用的树形结构
> 根本目的 : 降低IO操作次数 , 每访问一次节点都会进行一次磁盘的I/O操作.

(1) 二叉树的局限性 : 在特殊情况下二叉树可能深度特别大 , 并且树的左右节点数量可能差距非常大 , 导致查询效率会因为数据不同有很大的差距
		(2)平衡二叉树 : 深度依然很大
		(3)B树 : 平衡多路搜索树

![img](../../resources/sql/btree.jpg)

> 每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶

> 每个磁盘块中包括了关键字和子节点的指针

> 如果一个磁盘块中包括了 x 个关键字，那么指针数就是 x+1 (上图中包含两个关键字,将数据分为3部分 , 所以指针有三个)

一个 M 阶的 B 树（M>2）有以下的特性：

- 根节点的儿子数的范围是[2,M]。
- 每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为$$[ceil(M/2), M]$$。 ceil : 返回大于或者等于指定表达式的最小整数
- 叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为$$[ceil(M/2), M]$$。
- 假设中间节点节点的关键字为：$$Key[1], Key[2], …, Key[k-1]$$，且关键字按照升序排序，即 $$Key[i]<Key[i+1]$$。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：$$P[1], P[2], …, P[k]$$，其中 P[1]指向关键字小于 Key[1]的子树，P[i]指向关键字属于 $$(Key[i-1], Key[i]) $$的子树，P[k]指向关键字大于 Key[k-1]的子树。所有叶子节点位于同一层。

(4)B+树 : 

- 有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数 +1。
- 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。
- 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，非叶子节点既保存索引，也保存数据记录。
- 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。

#### 2.为什么使用B+树

- B+ 树查询效率更稳定 : B+树的所有数据都存储在叶子节点,查询数据进行的IO操作次数是相同的.
- 通常B+树查询效率更高,因为B+树相比于B树更加矮胖,进行的IO操作更少
- 同样的磁盘页大小,B+树可以存储更多的节点关键字
- 对于范围查询更快 : B+树的叶子结点上通过有序链表进行了连接,B树需要通过中序遍历才能查找到.


#### 3.Hash索引 和 B+树索引区别
> **哈希索引是无序的**
- Hash 索引不能进行范围查询，而 B+ 树可以。这是因为 Hash 索引指向的数据是无序的，而 B+ 树的叶子节点是个有序的链表。
- Hash 索引不支持联合索引的最左侧原则（即联合索引的部分索引无法使用），而 B+ 树可以。对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。
- Hash 索引不支持 ORDER BY 排序，因为 Hash 索引指向的数据是无序的，因此无法起到排序优化的作用，而 B+ 树索引数据是有序的，可以起到对该字段 ORDER BY 排序优化的作用。同理，我们也无法用 Hash 索引进行模糊查询，而 B+ 树使用 LIKE 进行模糊查询的时候，LIKE 后面前模糊查询（比如 % 开头）的话就可以起到优化作用。
- MySQL的InnoDB 存储引擎有“自适应 Hash 索引”的功能 , 当某个索引值使用非常频繁时候会在B+树的索引基础上在创建一个Hash索引 , 这样让B+树具备了哈希索引的优点.

> 自适应哈希索引

​	1）自适应哈希索引只保存热数据（经常被使用到的数据），并非全表数据。因此数据量并不会很大，可以让自适应Hash放到缓冲池中，也就是InnoDB buffer pool，进一步提升查找效率。

​	2）InnoDB中的自适应Hash相当于是“索引的索引”，采用Hash索引存储的是B+树索引中的页面的地址。这也就是为什么可以称自适应Hash为索引的索引。
采用自适应Hash索引目的是可以根据SQL的查询条件加速定位到叶子节点，特别是当B+树比较深的时候，通过自适应Hash索引可以提高数据的检索效率。

​	3）自适应Hash采用Hash函数映射到一个哈希表中，所以对于字典类型的数据查找非常方便
哈希表是数组+链表的形式。通过Hash函数可以计算索引键值所对应的bucket（桶）的位置，如果产生哈希冲突，就需要遍历链表来解决。

​	4）是否开启了自适应Hash，可以通过innodb_adaptive_hash_index变量来查看，

​	比如：mysql> show variables like '%adaptive_hash_index';

