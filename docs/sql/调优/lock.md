# 锁：悲观锁和乐观锁

# 锁的种类

## 一. 按照锁的粒度进行划分
#### 1.1  行锁 : 按照行的力度进行数据锁定.
- 锁力度小,发生冲突概率低,可以实现的并发度高
- 锁开销大,加锁比较慢,容易出现死锁,多个事务对同一行的资源进行竞争.
- **行锁是基于索引加载的**，所以行锁是要加在索引响应的行上

> 在InnoDB中有三种行锁的方式：
> - 记录锁：针对单个行记录添加锁。锁的是表中的某一条记录，记录锁的出现条件**必须是精准命中索引并且索引是唯一索引**
> - 间隙锁（Gap Locking）：可以帮我们锁住一个范围（索引之间的空隙）**左开右闭**的区间，但不包括记录本身。采用间隙锁的方式可以防止幻读情况的产生。**间隙锁只会出现在可重复读的事务隔离级别中，mysql5.7默认就是可重复读**
> - Next-Key锁(临键所)：帮我们锁住一个范围，同时锁定记录本身，相当于间隙锁+记录锁，可以解决幻读的问题.临键锁的触发条件也是**查询条件命中索引**.临键锁锁定区间和查询范围后匹配值很重要，如果后匹配值存在，则只锁定查询区间，否则锁定查询区间和后匹配值与它的下一个值的区间。

例如 : 
```sql
-- 临键锁
-- 数据库中存在三条数据,主键分别为 1, 3, 5
-- 此时锁的范围是 (1,+∞) , 因为6之后的范围数据不存在
UPDATE user_name from t_user WHERE id > 1 and id < 6
-- 此时锁的范围是 (1,5) , 因为4之后的范围数据为5
UPDATE user_name from t_user WHERE id > 1 and id < 4
```

#### 1.2 页锁 : 按照页的力度进行数据锁定.
使用页锁时候,可能会出现数据浪费的现象,因为一个页中可以有多个行记录.

#### 1.3 表锁 : 对数据表进行锁定.
- 锁冲突概率高,数据访问并发度低.
- 锁使用开销小,加锁快

#### 1.4 其他
除了行,页,表以外,还可以在区和数据库力度上进行锁定,不同数据库和存储引擎支持的锁力度是不同的.

![image-20210610202719539](../../resources/sql/image-20210610202719539.png)

## 二. 从数据库管理的角度进行划分

#### 2.1 共享锁
共享锁也叫做读锁或S锁,共享锁锁定的资源可以被其他用户读取,但不能修改.
在进行SELECT时候,会将对象进行共享锁锁定,当数据读取完毕之后,就会释放共享锁,这样就可以保证数据在读取时候不被修改.

```sql
-- 表加锁
LOCK TABLE product_comment READ;
-- 表解锁
UNLOCK TABLE;

-- 行 共享锁
SELECT * FROM t_user WHERE user_id = 912178 LOCK IN SHARE MODE
```

##### 2.1.1  共享锁导致的死锁

例 : 
> 客户端1开启事务,采用读锁的方式进行查询,在事务没有提交的时候,这两行数据被加上了读锁.

> 客户端2开启事务,再次使用读锁的方式对这两条数据进行查询,并且尝试执行修改,由于客户端1占有了读锁,所以客户端2会一致等待,直到超时,重新执行事务.


#### 2.2  排它锁

排它锁也叫独占锁、写锁或 X 锁。排它锁锁定的数据只允许进行锁定操作的事务使用，其他事务无法对已锁定的数据进行查询或修改。

当我们对数据进行更新的时候,也就是INSERT,DELETE或者UPDATE时候,数据库也会自动使用排它锁,防止其他事务对该数据行进行操作.

```sql
-- 表 写锁
LOCK TABLE product_comment WRITE;
-- 表解锁
UNLOCK TABLE;

-- 行 排他锁
SELECT * FROM t_user WHERE user_id = 912178 FOR UPDATE;
```

#### 2.3 意向锁 : 告诉别人这个空间中是否上过锁
例 : 
> 如果我们给某一行的数据加上了排它锁,数据库会自动给更大一级的空间,比如数据页或者数据表加上意向锁,告诉其他人这个数据页或数据表已经有人上过排它锁了.这样其他人想要获取数据表的排它锁时候,只要确认是否有人获取了这个数据表的意向排它锁即可.

## 三. 从程序员角度进行划分

### 3.1 乐观锁
前提 : 对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现.

实现 : 可以采用版本号机制或者时间戳机制实现

#### 3.1.1 乐观锁的版本号机制
```sql
-- 1.通过在表中增加一个版本字段,第一次读的时候会获取version的值
-- 2.进行数据的更新,这个时候会执行如下SQL
UPDATE ... set version=version+1 WHERE version=version
-- 如果已经有事务对这条数据进行了更改,修改就不会成功.
```

#### 3.1.2 乐观锁的时间戳机制
时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。


### 3.2 悲观锁
对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。像行锁,表锁,共享锁,排它锁.

### 3.3 使用场景

- 乐观锁 : 乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。


- 悲观锁 : 悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读-写 和 写-写的冲突。


## 四. 如何避免死锁

- 如果事务涉及多个表，操作比较复杂，那么可以尽量一次锁定所有的资源，而不是逐步来获取，这样可以减少死锁发生的概率；
- 如果事务需要更新数据表中的大部分数据，数据表又比较大，这时可以采用锁升级的方式，比如将行级锁升级为表级锁，从而减少死锁产生的概率；
- 不同事务并发读写多张数据表，可以约定访问表的顺序，采用相同的顺序降低死锁发生的概率。

## 参考资料
- [浅谈数据库共享锁与排它锁](https://zhuanlan.zhihu.com/p/52879825)
- [深入理解数据库行锁与表锁](https://zhuanlan.zhihu.com/p/52678870)

























































