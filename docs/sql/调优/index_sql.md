# 如何通过索引让SQL执行更高效

# 一.什么样的字段应该创建索引 
1. **字段的数值有唯一性的限制 ， 比如用户名**
2. **频繁作为 where 查询条件的字段，尤其在数据表大的情况下**
3. **需要经常 group by 和 order by 的列**

- 实际上多个单列索引在多条件查询时只会生效一个索引（MySQL 会选择其中一个限制最严格的作为索引），所以在多条件联合查询的时候最好创建联合索引。

- 在进行 SELECT 查询的时候，执行顺序是先进行 GROUP BY，再对数据进行 ORDER BY 的操作，所以按照这个联合索引的顺序效率是最高的。

4. **update delete 的where 条件列 ， 一般也需要创建索引**
- 如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护
- 不过如果索引太多了，在更新数据的时候，可能涉及到索引更新，就会造成负担。

5. **distinct 字段需要创建索引**
- 因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多.

6. **在进行多表 join连接操作时候，创建索引需要注意 ：** 
（1）连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。
（2）对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。
（3）对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致

7. **什么时候不需要创建索引**
（1）where 条件里用不到的字段不需要创建索引。
（2）如果表记录太少，不需要创建索引，例如少于 1000个
（3）字段中如果有大量重复数据，也不用创建索引
（4）频繁更新的字段，不一定要创建索引，因为更新数据时候也会更新索引，会造成负担，影响效率


# 二.什么情况下索引会失效 ： 

1. **如果索引进行了表达式计算**
2. **如果对索引使用了函数，也会造成失效**
3. **在where子句中，如果在or前的条件列进行了索引，而在or后的字段没有进行索引，那么索引会失效**
- 因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列进行了索引是没有意义的，只要有条件列没有进行索引，就会进行全表扫描，因此索引的条件列也会失效, 而and就不会.
4. **当我们使用 LIKE 进行模糊查询的时候，前面不能是 %**
5. **索引列尽量设置为 NOT NULL 约束 ： 节省测试字段值是否为null的开销**
 - 参考[官方解释](https://dev.mysql.com/doc/refman/8.0/en/data-size.html )  : It makes SQL operations faster, by enabling better use of indexes and eliminating overhead for testing whether each value is NULL.
6. **使用联合索引的时候要注意最左原则**


