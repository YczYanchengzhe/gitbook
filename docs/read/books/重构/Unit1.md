# 重构

## 什么是重构?

> 重构 : 在**不改变代码外在行为**的前提下,对代码作出修改,以**改进程序的内部结构**.

如果你要给程序添加新的特性,但是发现代码因为缺乏良好的结构而不易进行更改,那就先重构那个程序,使其比较容易添加该特性,然后再添加该特性.


## 重构的第一步
- 确保即将修改的代码拥有一组可靠的测试 , 并且这些测试拥有自我检验的能力
- 提炼函数
- 无论每次重构多么简单,重构之后立即运行测试 , 每次改动之后都要提交代码,并把零碎的修改压缩成一个更有意义的提交(commit)
- 变量改名 , 将函数的返回值命名为`result`,只要改名能够提高代码的可读性,那就应该去做.
- 以查询来取代临时变量
- 重构的第一步往往是把复杂的代码块分解为更小的单元,与好的命名一样都很重要.
- 对于重构的性能问题  : 大多数情况下可以忽略 , 如果重构引入了性能损耗 , 先完成重构,在做性能优化.
- 添加新功能最快的办法是修改现有代码


## 什么时机去重构
- 一件事情,如果做了三次重复的工作,就应该反思是不是需要重构了.
- 一段代码,如果不需要修改他,name 我们可以不去重构他,只有当我需要去理解他的含义时候,重构才有意义.

## 重构的场景
- 预备性重构 : 在添加新功能之前,此时最适合重构,查看当前的代码库,对代码做一些微调,可以帮助工作更加容易的完成.
- 帮助理解的重构 : 在思考这个代码到底在做什么时候,同时思考,能不能重构这段代码,让其更加一目了然 , 尽量把该记住的东西写在代码里
- 捡垃圾式重构 : 如果当前不想进行重构(这里指的是,需要修改的部分) , 借助便签,把需要重构的地方记下来,在完成功能之后在进行重构.


## 重构的挑战
- 新功能的延后
- 代码所有权导致的无法修改
- 分支开发,由于重构可能导致函数调用或者命名修改引入的合并代码困难
- 没有足够的测试,导致重构无从入手,或者引入不可预期的 Bug
- 对于代码活性的抉择 : 是否需要让代码为未来的变化添加活性,这里要考虑到重构的困难程度,如果很难重构,那么有必要为其添加一定的活性,否则优先以最优的方式完成现有的需求即可.





