# 分布式缓存


# 一. 缓存
##  1. 数据分类 : 
> 从数据的使用上把数据的使用频率和方式分类 : 

- 静态数据 : 一般不变,类似于字典表
- 准静态数据 : 变化频率低
- 中间状态数据 : 计算的可复用中间数据

------------------------------------------------

- 热数据 : 使用频率高
- 读写比较大 : 读 >> 写

## 2. 缓存到底是什么?
上面这些数据适用于缓存 , 总而言之缓存是为了加速数据处理 ,让业务更快的访问的临时存放的冗余数据. 一般把分布式系统中缓存到内存的数据叫做内存缓存.扩展来说 : 内存可以看做CPU和磁盘之间的缓存.网络以及数据中的各种Buffer都可以看做缓存,像GUI的Double Buffer(双缓冲)可以看做缓存的应用.

## 3. 缓存本质 : 
系统各级处理速度不匹配  使用空间换时间 , 缓存是提高系统性能的简单有效的方法.


## 4. 缓存加载时机
(1) 启动全量加载 : 全局有效,使用简单
(2) 懒加载 : 同步加载  , 异步加载
同步使用加载 ==>
- 查看缓存是否有,没有的话从数据库读取
- 读取的数据放到内存,之后返回给用户

延迟异步加载 ==> 
-  从缓存中获取数据,不管是否有,直接返回
- 策略1 : 为null ,发起异步线程,加载数据
- 策略2 : 异步线程,定期执行更新

例子 : 像 sharding 缓存了1024个sql,但是缓存的是查询的sql,如果不使用预加载,会因为参数不同而导致缓存失效,所以建议使用预加载.

## 5. 缓存的有效性与数据同步.
#### 为什么变动频率大,一致性要求高的数据不适合缓存?
变动频率大说明,内存和缓存一致有差异,
一致性要求高,只有使用原始数据,甚至加了事务才是保险的,
基于上面两点,这样的数据不适合放在缓存中.

#### 如何评价缓存的有效性?
读写比 : 对数据写操作意味着数据变动,N:1
命中率 L缓存数据被使用意味着有价值. 90%
实际上上面的标准也可以作为一个使用,权衡缓存的一个标准

#### 缓存使用不当的后果
- 系统预热导致启动慢(预先加载缓存非常多)
- 内存资源耗尽(缓存没有定期清理)

# 二. 本地缓存 : 
>
Hibernate/Mybatis 都有缓存
一级缓存 ,session级别 , 某一个事务级别
二级缓存 ,sessionFactory级别 , 全局缓存 (默认不开启,需要手动开启)

## 1. 常用缓存 : 
(1) ehcache : 
相关资料
https://www.ehcache.org/
https://www.sojson.com/blog/190.html

(2) guava cache : 
功能 : 缓存大小,过期时间,弱引用,显式清除,统计信息,移除事件监听器,自动加载

(3) spring cache : 
功能 : 基于注解 aop , 可以配置 condition和spel , 核心功能 @Cacheable , @CachePut (类似于guava的自动加载),@CacheEvict , 通过注解让缓存失效
注意 : 如果绕过Spring 缓存失效
注释驱动的 Spring cache 缓存介绍
https://developer.ibm.com/zh/articles/os-cn-spring-cache/



# 三. 远程缓存 : 
> 本地缓存缺点 : 
>	1. 多集群同步
>	2. jvm中,如果堆内存,影响GC
>	3. 缓存数据处理影响业务执行的资源
> 正是由于本地缓存存在这些问题,所以可以使用集中处理缓存

## 1. Redis/Memcache 缓存中间件
#### (1) redis/Memcache简介
REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSIC语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 

Memcached是以LiveJournal旗下Danga Interactive公司的Brad Fitzpatric为首开发的 一款开源高性能，分布式内存对象缓存系统。

#### (2) 相关文档
Redis 官网：https://redis.io/ 
Redis 在线测试：http://try.redis.io/ 
Redis 命令参考：http://doc.redisfans.com/ 
《Redis 设计与实现》：http://redisbook.com/ 
Memcached 官网：https://memcached.org/


## 2. Hazelcast/Ignite 内存网格

# 四. 缓存策略 
1. 按照容量评估缓存的使用 : 由于资源有限,系统在设计时候需要考虑到缓存容量,使用容量,峰值等信息.
2. 过期策略 : 
- FIFO/LRU(最近最少使用)
- 固定时间过期
- 业务加权(以机票为例,大多数业务都是买最近两天的 ,所以缓存时候可以按照时间,距离越远缓存时间越长)


# 五. 缓存问题
## 1. 缓存穿透 : 
问题 : 大量并发**查询不存在的key** , 导致数据库压力过大
解决 : 

1. 对于空值的key,第一次不存在页会加载记录 ,下次拿到这个key
2. 完全缓存为准 , 使用延迟异步加载
3. 使用 Bloom过滤(布隆过滤)或者RoaringBitmap(占用内存大于布隆过滤)判断key是否存在. 判断哪些key在缓存中

## 2. 缓存击穿
问题 : 某个**key失效**时候,**正好**有大量key访问
解决 : 

1. 更新增加全局的互斥锁
2. 完全缓存为准 , 使用延迟异步加载

## 3. 缓存雪崩
问题 : 当某一时刻发生**大规模缓存失效**,有大量请求打到数据库,导致数据库崩溃
解决 : 

1.  更新策略在时间上尽可能均匀
2. 使用的热数据尽量分散在不同机器上
3. 多台机器进行主从复制,多副本,保证高可用
4. 实现熔断限流,控制负载


# 其他知识 : 
## 1. guava 和 ehcache
https://blog.csdn.net/lusteiger/article/details/84850433

## 2. Redis 缓存更新一致性
https://www.cnblogs.com/Finley/p/12615111.html

