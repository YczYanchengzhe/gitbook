# 管理设计

## 一. 分布式锁

### 1.1 基本要求
- 安全性（Safety）：在任意时刻，只有一个客户端可以获得锁（排他性）。
- 避免死锁：客户端最终一定可以获得锁，即使锁住某个资源的客户端在释放锁之前崩溃或者网络不可达。
- 容错性：只要锁服务集群中的大部分节点存活，Client 就可以进行加锁解锁操作。

### 1.2 相关实现
[锁的实现](../java/Java并发/Lock.md) 

### 1.3 是否真的需要分布式锁
- 对于修改某个共享资源的场景,可以使用 CAS 的方式,不一定要用分布式锁
- 保证不同进程的同步或者互斥,才需要分布式锁

## 二. 配置中心

### 2.1 配置的划分 : 
#### 2.1.1 静态配置
静态配置其实就是在软件启动时的一些配置，运行时基本不会进行修改，也可以理解为是环境或软件初始化时需要用到的配置。
#### 2.1.2 动态配置
- 按运行环境分。一般来说，会有开发环境、测试环境、预发环境、生产环境。这些环境上的运行配置都不完全一样，但是理论来说，应该是大同小异的。
- 按依赖区分。一种是依赖配置，一种是不依赖的内部配置。比如，外部依赖的 MySQL 或 Redis 的连接配置。还有一种完全是自己内部的配置。
- 按层次分。就像云计算一样，配置也可以分成 IaaS、PaaS、SaaS 三层。基础层的配置是操作系统的配置，中间平台层的配置是中间件的配置，如 Tomcat 的配置，上层软件层的配置是应用自己的配置。

### 2.2 配置中心的架构思考

**为什么需要一个变更通知的组件，而不是让配置中心直接推送？** 
		原因是，分布式环境下，服务器太多，推送不太现实，而采用一个 Pub/Sub 的通知服务可以让数据交换经济一些。

**为什么不直接 Pub 数据过去，还要订阅方反向拉数据？**

直接推数据当然可以，但让程序反过来用 API 读配置的好处是，一方面，API 可以校验请求者的权限，另一方面，有时候还是需要调用配置中心的基本 API

**配置变更控制器部署在哪里？是在每个服务器上呢，还是在一个中心的地方?**

建议把这个配置变更的控制放在每一台主机上。类似于 agent.

**平台层的配置变更，有的参数是在服务启动的命令行上，这个怎么变更呢？**

一般来说，命令行上的参数需要通过 Shell 环境变量做成配置项，然后通过更改系统环境变量，并重启服务达到配置变更。

**应用服务配置更新如何标准化?**

- 通过一个开发框架或 SDK 的方式来解决，也就是应用代码找你这个 SDK 来要配置，并通过 observer 模式订阅配置修改的事件
- 一个标准应用运维脚本，让应用方自己来提供应用变更时的脚本动作

## 三.边车模式

**编程的本质就是将控制和逻辑分离和解耦，而边车模式也是异曲同工，同样是让我们在分布式架构中做到逻辑和控制分离。**

### 3.1 解决的问题
对于控制和逻辑的分离,
对于**监视、日志、限流、熔断、服务注册、协议转换**等等这些功能的解决方案 : 

- 一种是通过 SDK、Lib 或 Framework 软件包方式，在开发时与真实的应用服务集成起来。

- 另一种是通过像 Sidecar 这样的方式，在运维时与真实的应用服务集成起来。


### 3.2 优缺点

- 对应用有侵入,受编程语言限制,软件包升级时候,需要重新编译发布.
- sidecar 方式,对应用无侵入,不受语言限制.但是增加了每个应用服务的依赖性以及应用延迟,增加管理托管部署的复杂度.

### 3.3 工程实现注意
- 进程间的通讯协议 : 不要使用任何对应用服务有侵入的方式(信号,或者共享内存),最好使用远程网络调用的方式
- 服务协议方面，也请使用标准统一的方式。这里有两层协议，一个是 Sidecar 到 service 的内部协议，另一个是 Sidecar 到远端 Sidecar 或 service 的外部协议。对于内部协议，需要尽量靠近和兼容本地 service 的协议；对于外部协议，需要尽量使用更为开放更为标准的协议。但无论是哪种，都不应该使用与语言相关的协议。
- 使用这样的模式，需要在服务的整体打包、构建、部署、管控、运维上设计好。使用 Docker 容器方面的技术可以帮助你全面降低复杂度。
- Sidecar 中所实现的功能应该是控制面上的东西，而不是业务逻辑上的东西，所以请尽量不要把业务逻辑设计到 Sidecar 中。
- 小心在 Sidecar 中包含通用功能可能带来的影响。例如，重试操作，这可能不安全，除非所有操作都是幂等的。
- 允许应用服务和 Sidecar 的上下文传递的机制


### 3.4 使用场景
**适用**

- 一个比较明显的场景是对老应用系统的改造和扩展。
- 另一个是对由多种语言混合出来的分布式服务系统进行管理和扩展。其中的应用服务由不同的供应商提供。
- 把控制和逻辑分离，标准化控制面上的动作和技术，从而提高系统整体的稳定性和可用性。也有利于分工——并不是所有的程序员都可以做好控制面上的开发的。

**不适用**
- 架构并不复杂的时候，不需要使用这个模式，直接使用 API Gateway 或者 Nginx 和 HAProxy 等即可。
- 服务间的协议不标准且无法转换。
- 不需要分布式的架构。

## 四. 服务网格

### 4.1 什么是 service-mesh
Service Mesh 这个服务网络专注于处理服务和服务间的通讯。其主要负责构造一个稳定可靠的服务通讯的基础设施，并让整个架构更为的先进和 Cloud Native。在工程中，Service Mesh 基本来说是一组轻量级的服务代理和应用逻辑的服务在一起，并且对于应用服务是透明的。

- Service Mesh 是一个基础设施。
- Service Mesh 是一个轻量的服务通讯的网络代理。
- Service Mesh 对于应用服务来说是透明无侵入的。
- Service Mesh 用于解耦和分离分布式系统架构中控制层面上的东西。

[Service Mesh 的出现并不是一个偶然，而是一个必然](https://philcalcado.com/2017/08/03/pattern_service_mesh.html)

### 4.2 service-mesh 的开源组件

目前比较流行的 Service Mesh 开源软件是 [Istio](https://istio.io/) 和 [Linkerd](https://linkerd.io/)




## 五.网关模式

### 5.1 功能
**基本功能**

- 请求路由
- 服务注册
- 负载均衡
- 弹力设计
- 安全方面

**其他功能**

- 灰度发布
- API 聚合
- API 编排

### 5.2 设计
- 高性能
- 高可用 : 集群化,服务化,持续化
- 高扩展 : 

### 5.3 运维
- 业务松耦合，协议紧耦合
- 应用监视，提供分析数据
- 用弹力设计保护后端服务
- DevOps

### 5.4 安全相关
- 加密数据
- 校验用户的请求
- 检测异常访问


## 六. 部署升级策略

#### 6.1 部署方式 : 
- 停机部署（Big Bang / Recreate）： 把现有版本的服务停机，然后部署新的版本。
- 蓝绿部署（Blue/Green /Stage）：部署好新版本后，把流量从老服务那边切过来。
- 滚动部署（Rolling Update / Ramped）： 一点一点地升级现有的服务。
- 灰度部署（Canary）：把一部分用户切到新版本上来，然后看一下有没有问题。如果没有问题就继续扩大升级，直到全部升级完成。
- AB 测试（A/B Testing）：同时上线两个版本，然后做相关的比较。

#### 6.2 停机部署
简单地把现有版本的服务停机，然后部署新的版本
- 优势是，在部署过程中不会出现新老版本同时在线的情况，所有状态完全一致。停机部署主要是为了新版本的一致性问题。
- 会停机，对用户的影响很大。所以，一般来说，这种部署方式需要事前挂公告，选择一个用户访问少的时间段来做。

#### 6.3 蓝绿部署
- 蓝绿部署与停机部署最大的不同是，其在生产线上部署相同数量的新服务，然后当新的服务测试确认 OK 后，把流量切到新的服务这边来。蓝绿部署比停机部署好的地方是，它无需停机。
- 问题在于有点浪费资源，因为需要使用双倍的资源
- 如果我们的服务中有状态，比如一些缓存什么的，停机部署和蓝绿部署都会有问题

#### 6.4 滚动部署
滚动部署策略是指通过逐个替换应用的所有实例，来缓慢发布应用的一个新版本

**问题 :** 

- 在发布过程中，会出现新老两个版本同时在线的情况，同一用户的请求可能在新老版中切换而导致问题。
- 新版程序没有在生产环境验证,对于此一般都会有一个沙箱环境来进行功能验证.
- 在整个过程中，生产环境处于一个新老更替的中间状态，难以回滚。
- 如果在升级过程中，需要做别的一些运维工作，我们还要判断哪些结点是老版本的，哪些结点是新版本的。因为新老版本的代码同时在线，所以其依赖的服务需要同时处理两个版本的请求，这可能会带来兼容性问题。
- 无法让流量在新老版本中切换。

#### 6.5 灰度部署

灰度部署是指逐渐将生产环境流量从老版本切换到新版本。通常流量是按比例分配的。例如 90% 的请求流向老版本，10% 的请求流向新版本。然后没有发现问题，就逐步扩大新版本上的流量，减少老版本上的流量。

除了切流量外，对于多租户的平台，例如云计算平台，灰度部署也可以将一些新的版本先部署到一些用户上，如果没有问题，扩大部署，直到全部用户。一般的策略是，从内部用户开始，然后是一般用户，最后是大客户。

这个技术大多数用于缺少足够测试，或者缺少可靠测试，或者对新版本的稳定性缺乏信心的情况下。


#### 6.6 AB 测试

AB 测试是同时上线两个版本，然后做相关的比较。它是用来**测试应用功能表现**的方法，例如可用性、受欢迎程度、可见性等。

蓝绿部署是为了不停机，灰度部署是对新版本的质量没信心。而 AB 测试是对新版的功能没信心。注意，一个是质量，一个是功能。





