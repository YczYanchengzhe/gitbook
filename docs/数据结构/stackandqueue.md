# 栈和队列
栈和队列可以理解为 : `操作受限`的线性表,栈只允许一段插入和删除 , 只支持入栈出栈 , 队列只支持入队和出队.
栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，叫作顺序栈，用链表实现的栈，叫作链式栈。队列也一样,分为顺序队列和链式队列.
![img](..\resources\sql\stack_queue.jpg)

## 一.栈 : LIFO
#### 1.简介


> 普通栈
空间复杂度 : O(1)
时间复杂度 : O(1)

> 可动态扩展栈
空间复杂度 : O(1)
时间复杂度 : 最好时间复杂度 : O(1) , 最差时间复杂度 : O(n) , 均摊时间复杂度 : O(1)

#### 2.应用 : 

- 函数调用栈

```C++
int main() {
   int a = 1; 
   int ret = 0;
   int res = 0;
   ret = add(3, 5);
   res = a + ret;
   printf("%d", res);
   reuturn 0;
}

int add(int x, int y) {
   int sum = 0;
   sum = x + y;
   return sum;
}
```

![img](..\resources\sql\funstack.jpg)


- 表达式求值

3入栈 , + 入栈 , 5入栈 ,\*入栈 , 8入栈 , -优先级低 , 5出栈 , 8出栈 ,\*出栈,计算结果,结果入栈 , - 入栈 , 6入栈,再次计算获取最终结果.
![img](..\resources\sql\calcstack.jpg)

- 括号匹配



## 二.队列 : FIFO


#### 1.应用
>循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。

#### 2.顺序队列和链式队列
数组,链表实现的队列 , 使用数组实现队列在队列满了的时候需要进行数据搬移,此时的入队操作会O(n)

#### 3.循环队列
>解决了顺序队列的数据搬移问题 , 需要注意队列的空和满判断 : (tail+1)%n=head ,
正常tail + 1 = head , 但是tail=n-1 ,head =0 时,此时 tail+ 1 = n.所以需要对n取余.

>在队列满了的时候,tail指向的位置并没有存储数据,所以循环队列会浪费一个数组的存储空间(因为tail + 1 有数据,所以tail没有办法指向下一个位置)

![img](../resources/sql/queue.jpg)

#### 4.阻塞队列和并发队列
- 阻塞队列 : 队列为空的时候，从队头取数据会被阻塞 , 队列已经满了，那么插入数据的操作就会被阻塞 . 生产者-消费者模型.
- 并发队列  : 解决多个线程同时操作队列出现的线程安全问题.

并发队列的实现 : 
(1) 在 enqueue()、dequeue() 方法上加锁
(2) 基于数组的循环队列,利用CAS原子操作.

#### 5. 在有限资源上的应用
> 对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。

**例子 :** 

线程池没有空闲线程时候新的任务处理策略是什么? 
(1) 非阻塞 : 直接拒绝
(2) 阻塞 : 请求排队(使用队列存储)

对于阻塞的情况  : 
使用链表实现的队列 , 支持无限排队,但是请求处理的响应时间会比较长,不适用于响应时间敏感系统.
使用数组实现的队列 , 线程池中排队的请求超过队列大小,接下来的请求会被拒绝.适用于响应时间敏感系统.


## 三.练习

#### 1. 数组/链表实现栈/队列

#### 2. 循环队列

#### 3. 并发队列 : 加锁 , CAS