# Trie树 - 字典树


## 一. 相关知识
- Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起
- 构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。
- 构建好 Trie 树后，在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。

## 二. Trie 树的内存损耗

因为它是使用数组来存储一个节点的子节点的指针,如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组元素要存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。

对此,我们可以进行一些优化手段,比如不适用数组来存储,而是使用有序数组、跳表、散列表、红黑树等。


- 假设我们用有序数组，数组中的指针按照所指向的子节点中的字符的大小顺序排列。查询的时候，我们可以通过二分查找的方法，快速查找到某个字符应该匹配的子节点的指针。但是，在往 Trie 树中插入一个字符串的时候，我们为了维护数组中数据的有序性，就会稍微慢了点。
- 有序数组查找方面，维护难，跳表查找方便但是容易退化，且耗空间。散列表容易散列冲突，红黑树需要一定的数据量
- 缩点优化，就是对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并



# 三. 使用场景
- 字符串中包含的字符集不能太大。如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。
- 要求字符串的前缀重合比较多，不然空间消耗会变大很多。
- 如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。
- 通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会有所损耗。

**所以一般情况下,针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树。Trie 树比较适合的是查找前缀匹配的字符串**




# AC 自动机
- AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了



