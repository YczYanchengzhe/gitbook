# 堆

| 排序算法 | 是否是原地排序 | 是否稳定 | 最好时间复杂度 | 最差时间复杂度 | 平均时间复杂度 |
| -------- | -------------- | -------- | -------------- | -------------- | -------------- |
| 堆排序   | 是             | 不是     | `O(nlogn)`     | `O(nlogn)`     | `O(nlogn)`     |



# 一. 定义

- 堆是一个完全二叉树；
- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

```java
public void sort(int[] nums, int start, int end) {
		// 从 最后一个非叶子结点进行查找
		for (int i = nums.length / 2 - 1; i >= 0; i--) {
			adjust(nums, i, nums.length);
		}
		// 交换堆顶和堆尾元素
		for (int i = nums.length - 1; i >= 0; i--) {
			swap(nums, i, 0);
			adjust(nums, 0, i);
		}
	}

	/**
	 * 调整某个元素 : 查看该元素是不是孩子中最大的
	 *
	 * @param nums   待调整的数据集
	 * @param index  需要调整的下标
	 * @param length 数据集长度(在进行堆排序之后,长度会不断减小)
	 */
	private void adjust(int[] nums, int index, int length) {
		int tmp = nums[index];
		for (int i = index * 2 + 1; i < length; i = i * 2 + 1) {
			// 找两个孩子中的相对较大的那个
			if (i + 1 < length && nums[i] > nums[i + 1]) {
				i++;
			}
			if (nums[i] < tmp) {
				nums[index] = nums[i];
				index = i;
			} else {
				break;
			}
		}
		nums[index] = tmp;
	}
```

## 二. 为什么堆排序没有快排友好

- 堆排序数据访问方式没有快排友好,下标的跳跃访问的.对 CPU 缓存不友好
- 对于同样的数据,在排序过程中,堆排序算法数据交换次数多余快排(因为堆排序在建堆的时候会打乱数据顺序,可能导致有序度降低)



## 三. 应用

### 3.1 优先级队列
队列最大的特性就是先进先出。不过，在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。实际上堆本身就是一个优先级队列.

可以使用优先级队列的场景有 :
-  合并有序小文件. 假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件 这里如果文件过大,可以先使用哈希进行文件拆分,之后每次再文件中取出一个数据,对于取出的这 100 个数据构建堆,之后堆顶放到结果文件中,在堆顶对应的原始文件中再次取出一条数据
-  高性能定时器 : 假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点.可以按照触发时间构建小顶堆,这样堆顶就是下次要执行的时间了,不需要定时扫描


### 3.2 利用堆求 Top K
#### 3.2.1 静态数据集合
- 静态数据集合，也就是说数据集合事先确定，不会再变
```
针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。
```
#### 3.2.2 动态数据集合
- 动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。

```
针对动态数据求得 Top K 就是实时 Top K.如果每次询问前 K 大数据，我们都基于当前的数据重新计算的话，那时间复杂度就是 O(nlogK)，n 表示当前的数据的大小。实际上，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。
```

### 3.3 堆求中位数,Tp99,Tp50等

#### 3.3.1 解决方案

维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。

对于Tp99,Tp50等实现方式是类似的,只不过两个堆的大小要求不一样,在中位数时,两个堆最多相差一个元素,在计算 Tp99 时候,大顶堆占比 99%的元素,小顶堆占比 1%的元素,这样每次从大顶堆取出的数据就是需要的数据了.

#### 3.3.2 实现方式



- 维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。
- 如果有 n 个数据，n 是偶数，我们从小到大排序，那前 n/2 个数据存储在大顶堆中，后 n/2 个数据存储在小顶堆中。这样，大顶堆中的堆顶元素就是我们要找的中位数。如果 n 是奇数，情况是类似的，大顶堆就存储 n/2+1 个数据，小顶堆中就存储 n/2 个数据。
- 如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。
- 如果两个堆的数据数量不满足我们最初的条件,就把一个堆的堆顶元素不停地移动到另一个堆.







