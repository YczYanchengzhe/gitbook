# 跳表

## 一. 概念

通过链表增加多级索引的结构,增加查询效率,这种结构就是跳表.

- 时间复杂度  : O(logn)
- 空间复杂度 : O(n)

> 实际上，在软件开发中，我们不必太在意索引占用的额外空间。在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了

## 二. 索引的动态更新
- 跳表是通过随机函数来维护`平衡性`,比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。

## 三. 为什么 Redis 要用跳表来实现有序集合，而不是红黑树？
1. 操作上 : Redis 核心操作 : 插入,删除,查找,区间查找,迭代输出有序数列.插入删除查找以及迭代输出有序数列和红黑树的复杂度是一样的,但是区间查找红黑树的效率没有跳表高.
2. 实现 : 相比于红黑树,跳表实现更加简单
3. 灵活 : 可以通过改变索引结构的策略,有效平衡执行效率和内存消耗.



# 散列表
散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。

## 一. 散列表核心要点
- 初始容量 : 如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高性能。
- 散列函数 : 我们可以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。
- 数据的自动扩容和装载因子
- 解决数据冲突


## 二. 散列函数
### 2.1 散列函数设计的基本要求 : 
- 散列函数计算得到的散列值是一个非负整数
- 如果 key1 = key2，那 hash(key1) == hash(key2)
- 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2) : 相对来说很难实现,所以需要解决哈希冲突

- 散列函数生成的值要尽可能随机并且均匀分布,避免或者最小化散列冲突
- 散列函数不能太复杂,否则计算散列函数的成本会影响到整体数据的操作


## 三. 数据自动扩缩容 - 装载因子
### 3.1 装载因子过大了怎么办？
装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链,查找的过程也会因此变得很慢。

可以对于散列表增加自动扩缩容的处理

### 3.2 如何避免低效的扩容?
**场景 :** 
	插入一个数据的操作都很快，但是，极个别非常慢的插入操作(碰见扩缩容)，也会让用户崩溃。这个时候，“一次性”扩容的机制就不合适了。

**解决 :** 
	为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。
	当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。
	当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。
	对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。

通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。


## 四. 解决数据冲突

不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。
装载因子的计算公式是：散列表的装载因子=填入表中的元素个数/散列表的长度

### 4.1 开放寻址法
#### 4.1.1 线性探测法 : 
**插入,查找,删除**
- 插入 : 如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止.
- 查找 : 我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。
- 删除 : 需要注意,手动删除后的元素因为曾经有值,现在没值,会对于查找数据有影响.对于这个问题 : 我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。

**存在的问题**
当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据.

#### 4.1.2 二次探测 : 

二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……

#### 4.1.3 双重散列 : 
使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。

### 4.2 链表法
对于散列值相同的元素我们都放到相同槽位对应的链表中。
当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。
当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除.时间复杂度 O(k).这个和链表的长度有直接关系,并且这个复杂度也可通过.

## 4.3 如何选择冲突解决方法？
Java 中 LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。为什么这么选择那?

### 4.3.1 开放寻址法优缺点 : 
- 优点 : 开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。
- 缺点 : 用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，**装载因子的上限不能太大**。这也导致这种方法比链表法更浪费内存空间。

**当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。**

### 4.3.2 链表法优缺点 : 

- 优点 : 链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多.
- 缺点 : 链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。

**基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表**

# 五. 为什么链表总是哈希表混合使用
散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。**如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。那效率势必会很低**。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。









