# 复杂度分析



 ## 为什么需要复杂度分析？ 

> 事后统计法 : 执行一次代码, 通过统计、监控得到算法执行的时间和占用的内存大小 .

事后统计法局限性 : 

1. 测试结果非常依赖于测试环境 : 可能测试的硬件变更会直接影响到测试的结果.
2. 测试结果收数据规模影响.

所以我们需要一中不需要测试数据来测试,就可以粗略估算算法执行效率的方法 -- 复杂度分析



## 大O复杂度表示法

规律 : 所有代码的执行时间都和每一行代码的执行次数成正比.   

$$T(n)=O(f(n))$$

$$T(n)$$表示代码执行时间,n表示数据规模的大小,
$$f(n)$$表示每行代码的执行次数总和,
O表示代码的执行时间$$T(n)$$和$$f(n)$$表达式成正比.

以上的表达方法就是大O复杂度表示法,大O复杂度表达法并不表示代码具体的执行时间,而是表达代码随着时间增长的一个变化趋势,也称渐进时间复杂度,简称时间复杂度.

## 时间复杂度分析
### 1.只关注循环执行次数最多的一段代码

### 2.加法法则 : 总复杂度等于量级最大的那段代码的复杂度
$$如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))$$

### 3.乘法法则 : 嵌套代码的总复杂度等于嵌套内外代码复杂度的乘积
$$如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))$$


## 常见的时间复杂度
常量阶 : $$O(1)$$
对数阶 : $$O(logn)$$
线性阶 : $$O(n)$$
线性对数阶: $$O(nlogn)$$
平方阶 : $$O(n^2)$$ .. 立方阶 : $$O(n^3)$$
指数阶 : $$O(2^n)$$
阶乘阶 :  $$O(n!)$$

上面的时间复杂度依次递增.
按照量级分类,可以分为多项式量级,非多项式量级,而非多项式量级只有两个 ： $$O(2^n)$$和$$O(n!)$$
我们把时间复杂度哦为非多项式量级的算法问题叫做NP（Non-Deterministic Polynomial，非确定多项式）问题

#### 1. $$O(1)$$
一版情况下,只要算法中不存在循环语句 ,递归语句,即使有成千上万行代码,其时间复杂度也是$$O(1)$$
#### 2. $$O(logn)$$和$$O(nlogn)$$
因为对数之间是可以互相转换的: $$log3n=log32 * log2n, O(log3n) = O(C * log2n)$$,所以,在采用大O标记复杂度时候,可以忽略系数.$$O(Cf(n)) = O(f(n))$$
#### 3. $$O(m+n)$$和$$O(m*n)$$
在代码复杂度由两个数据规模来决定时,由于事先不能评估量级,所以不能忽略.

## 空间复杂度分析

>空间复杂度 : 算法的存储空间与数据规模之间的增长关系

我们常见的空间复杂度就是 $$O(1)、O(n)、O(n2 )$$，像 $$O(logn)、O(nlogn) $$这样的对数阶复杂度其实很少用到。

## 最好,最坏,平均,均摊时间复杂度

> **最好情况时间复杂度** : 在最理想的情况下，执行代码的时间复杂度
> 
> **最坏情况时间复杂度** : 在最糟糕的情况下，执行代码的时间复杂度
> 
> **平均情况时间复杂度** : 加权平均时间复杂度或者期望时间复杂度,数值为概率论中的加权平均值，也叫作期望值
> 
> **均摊时间复杂度** : 将部分时间复杂度操作的耗时均摊到其他操作上.
> **使用场景** : 对于一组连续操作,大部分情况时间复杂度较低,个别情况较高,我们可以将较高时间复杂度操作的耗时,平摊到其他时间复杂度较低的操作上.
> 一般应用均摊时间复杂度的场合,均摊时间复杂度就是最好情况时间复杂度


## 空间换时间思想
> 当内存空间充足的时候, 如果我们更加追求电脑执行速度,我们可以选择空间复杂度较高,但是时间复杂度较低的算法或者数据结构
> 相反,如果代码运行在收集或者单片机上 , 那么可以使用时间换空间的设计思路







